#!/usr/bin/env python3
"""
Simple Personalization Integration
=================================

This service integrates lightweight embeddings with your existing outfit generation
system to add simple personalization without replacing your current validation.

Features:
- Works with existing outfit generation
- Adds personalization layer on top
- No external dependencies
- Simple to maintain
- Fallback to original system if needed
"""

import logging
import time
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

# Import lightweight services
from .lightweight_embedding_service import LightweightEmbeddingService, UserInteraction
from .lightweight_recommendation_engine import LightweightRecommendationEngine

logger = logging.getLogger(__name__)

@dataclass
class PersonalizedOutfitResult:
    """Result of personalized outfit generation"""
    outfits: List[Dict[str, Any]]
    personalization_applied: bool
    confidence: float
    metadata: Dict[str, Any]

class SimplePersonalizationIntegration:
    """
    Simple integration of personalization with existing outfit generation
    """
    
    def __init__(self):
        # Initialize lightweight services
        self.embedding_service = LightweightEmbeddingService()
        self.recommendation_engine = LightweightRecommendationEngine(self.embedding_service)
        
        # Settings
        self.enable_personalization = True
        self.min_interactions_for_personalization = 3  # Need at least 3 interactions
        self.max_personalized_outfits = 5
        
        logger.info("✅ Simple Personalization Integration initialized")
    
    async def generate_outfit_with_personalization(
        self,
        user_id: str,
        existing_outfit_generation_func,
        generation_context: Dict[str, Any],
        user_wardrobe: List[Dict[str, Any]] = None
    ) -> PersonalizedOutfitResult:
        """
        Generate outfit using existing system + add personalization layer
        
        Args:
            user_id: ID of the user
            existing_outfit_generation_func: Your current outfit generation function
            generation_context: Context for outfit generation
            user_wardrobe: User's wardrobe items
        """
        start_time = time.time()
        
        try:
            logger.info(f"🎯 Generating outfit with personalization for user {user_id}")
            
            # Step 1: Generate outfits using your existing system (keep this!)
            logger.info("📋 Using existing outfit generation system...")
            existing_outfits = await self._call_existing_outfit_generation(
                existing_outfit_generation_func, generation_context
            )
            
            if not existing_outfits:
                logger.warning("No outfits generated by existing system")
                return PersonalizedOutfitResult(
                    outfits=[],
                    personalization_applied=False,
                    confidence=0.0,
                    metadata={"error": "No outfits generated by existing system"}
                )
            
            logger.info(f"✅ Existing system generated {len(existing_outfits)} outfits")
            
            # Step 2: Check if user has enough interactions for personalization
            user_stats = self.embedding_service.get_user_embedding_stats(user_id)
            has_sufficient_data = user_stats["total_interactions"] >= self.min_interactions_for_personalization
            
            if not has_sufficient_data:
                logger.info(f"User {user_id} has {user_stats['total_interactions']} interactions, need {self.min_interactions_for_personalization} for personalization")
                logger.info("Using existing outfits without personalization")
                
                return PersonalizedOutfitResult(
                    outfits=existing_outfits[:self.max_personalized_outfits],
                    personalization_applied=False,
                    confidence=0.8,  # High confidence in existing system
                    metadata={
                        "reason": "insufficient_interactions",
                        "interactions": user_stats["total_interactions"],
                        "required": self.min_interactions_for_personalization,
                        "existing_system_used": True
                    }
                )
            
            # Step 3: Apply personalization if user has enough data
            if self.enable_personalization:
                logger.info("🎯 Applying personalization layer...")
                
                # Ensure user has embedding
                await self._ensure_user_embedding(user_id, user_wardrobe)
                
                # Apply personalization
                personalized_result = await self.recommendation_engine.generate_personalized_outfits(
                    user_id=user_id,
                    base_outfits=existing_outfits,
                    context=generation_context,
                    max_outfits=self.max_personalized_outfits
                )
                
                if personalized_result.outfits:
                    logger.info(f"✅ Personalization applied: {len(personalized_result.outfits)} outfits")
                    
                    return PersonalizedOutfitResult(
                        outfits=personalized_result.outfits,
                        personalization_applied=True,
                        confidence=personalized_result.confidence,
                        metadata={
                            "strategy_used": personalized_result.strategy_used.value,
                            "personalization_score": personalized_result.personalization_score,
                            "base_outfits_count": len(existing_outfits),
                            "personalized_outfits_count": len(personalized_result.outfits),
                            "generation_time": time.time() - start_time,
                            "existing_system_used": True,
                            "personalization_layer_applied": True
                        }
                    )
            
            # Step 4: Fallback to existing outfits if personalization fails
            logger.info("Using existing outfits as fallback")
            return PersonalizedOutfitResult(
                outfits=existing_outfits[:self.max_personalized_outfits],
                personalization_applied=False,
                confidence=0.8,
                metadata={
                    "reason": "personalization_failed_or_disabled",
                    "existing_system_used": True,
                    "fallback_applied": True
                }
            )
            
        except Exception as e:
            logger.error(f"❌ Outfit generation with personalization failed: {e}")
            
            # Emergency fallback to existing system
            try:
                logger.info("🚨 Emergency fallback to existing system...")
                existing_outfits = await self._call_existing_outfit_generation(
                    existing_outfit_generation_func, generation_context
                )
                
                return PersonalizedOutfitResult(
                    outfits=existing_outfits[:self.max_personalized_outfits],
                    personalization_applied=False,
                    confidence=0.7,
                    metadata={
                        "error": str(e),
                        "emergency_fallback": True,
                        "existing_system_used": True
                    }
                )
            except Exception as fallback_error:
                logger.error(f"❌ Emergency fallback also failed: {fallback_error}")
                
                return PersonalizedOutfitResult(
                    outfits=[],
                    personalization_applied=False,
                    confidence=0.0,
                    metadata={
                        "error": str(e),
                        "fallback_error": str(fallback_error),
                        "system_failed": True
                    }
                )
        
        finally:
            generation_time = time.time() - start_time
            logger.info(f"⏱️ Outfit generation with personalization completed in {generation_time:.2f}s")
    
    async def _call_existing_outfit_generation(
        self, 
        existing_outfit_generation_func, 
        generation_context: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Call your existing outfit generation function"""
        
        try:
            # Call your existing outfit generation function
            result = await existing_outfit_generation_func()
            
            # Extract outfits from result (handle different response formats)
            if isinstance(result, dict):
                outfits = result.get('outfits', []) or result.get('items', [])
            elif isinstance(result, list):
                outfits = result
            else:
                outfits = []
            
            logger.info(f"📋 Existing system generated {len(outfits)} outfits")
            return outfits
            
        except Exception as e:
            logger.error(f"❌ Existing outfit generation failed: {e}")
            return []
    
    async def _ensure_user_embedding(self, user_id: str, user_wardrobe: List[Dict[str, Any]] = None):
        """Ensure user has an embedding for personalization"""
        
        user_stats = self.embedding_service.get_user_embedding_stats(user_id)
        
        if not user_stats["has_embedding"]:
            logger.info(f"Creating initial embedding for user {user_id}")
            
            # Use wardrobe items to create initial embedding
            initial_items = user_wardrobe[:10] if user_wardrobe else []
            
            await self.embedding_service.generate_user_embedding(user_id, initial_items)
            logger.info(f"✅ Created initial embedding for user {user_id}")
        else:
            logger.info(f"User {user_id} already has embedding")
    
    async def record_user_interaction(
        self,
        user_id: str,
        outfit_id: Optional[str] = None,
        item_id: Optional[str] = None,
        interaction_type: str = "view",
        rating: Optional[float] = None
    ) -> bool:
        """Record user interaction for learning"""
        
        try:
            interaction = UserInteraction(
                user_id=user_id,
                outfit_id=outfit_id,
                item_id=item_id,
                interaction_type=interaction_type,
                rating=rating
            )
            
            success = await self.recommendation_engine.record_user_interaction(
                user_id, interaction
            )
            
            if success:
                logger.info(f"✅ Recorded {interaction_type} interaction for user {user_id}")
            else:
                logger.warning(f"⚠️ Failed to record {interaction_type} interaction for user {user_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"❌ Failed to record interaction: {e}")
            return False
    
    def get_personalization_status(self, user_id: str) -> Dict[str, Any]:
        """Get personalization status for a user"""
        
        user_stats = self.embedding_service.get_user_embedding_stats(user_id)
        
        return {
            "user_id": user_id,
            "personalization_enabled": self.enable_personalization,
            "has_user_embedding": user_stats["has_embedding"],
            "total_interactions": user_stats["total_interactions"],
            "min_interactions_required": self.min_interactions_for_personalization,
            "ready_for_personalization": user_stats["total_interactions"] >= self.min_interactions_for_personalization,
            "system_parameters": {
                "min_interactions": self.min_interactions_for_personalization,
                "max_outfits": self.max_personalized_outfits,
                "learning_rate": self.embedding_service.learning_rate,
                "exploration_rate": self.embedding_service.exploration_rate
            }
        }
    
    def update_settings(
        self,
        enable_personalization: Optional[bool] = None,
        min_interactions: Optional[int] = None,
        max_outfits: Optional[int] = None
    ):
        """Update personalization settings"""
        
        if enable_personalization is not None:
            self.enable_personalization = enable_personalization
        
        if min_interactions is not None:
            self.min_interactions_for_personalization = max(1, min_interactions)
        
        if max_outfits is not None:
            self.max_personalized_outfits = max(1, max_outfits)
        
        logger.info(f"✅ Updated personalization settings: enabled={self.enable_personalization}, min_interactions={self.min_interactions_for_personalization}")
