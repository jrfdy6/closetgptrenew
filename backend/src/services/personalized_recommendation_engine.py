#!/usr/bin/env python3
"""
Personalized Recommendation Engine
=================================

This engine integrates vector embeddings with outfit generation to provide
personalized recommendations based on user preferences and interaction history.

Features:
- Personalized outfit ranking using cosine similarity
- Integration with existing outfit generation pipeline
- Continuous learning from user interactions
- Exploration vs exploitation balance
- A/B testing capabilities for recommendation strategies
"""

import logging
import numpy as np
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import time

from .embedding_service import EmbeddingService, UserInteraction, EmbeddingType
from .enhanced_outfit_validator import EnhancedOutfitValidator

logger = logging.getLogger(__name__)

class RecommendationStrategy(Enum):
    """Different recommendation strategies"""
    PERSONALIZED = "personalized"  # Use user embeddings
    POPULAR = "popular"           # Use popularity-based ranking
    RANDOM = "random"             # Random selection
    HYBRID = "hybrid"             # Mix of personalized and popular

@dataclass
class RecommendationResult:
    """Result of recommendation process"""
    outfits: List[Dict[str, Any]]
    strategy_used: RecommendationStrategy
    personalization_score: float
    confidence: float
    metadata: Dict[str, Any]

class PersonalizedRecommendationEngine:
    """
    Engine for generating personalized outfit recommendations
    """
    
    def __init__(self, embedding_service: EmbeddingService):
        self.embedding_service = embedding_service
        self.validator = EnhancedOutfitValidator()
        
        # Recommendation parameters
        self.personalization_weight = 0.7  # Weight for personalized vs other factors
        self.exploration_rate = 0.1        # Rate of exploration vs exploitation
        self.min_similarity_threshold = 0.3  # Minimum similarity for recommendations
        
        # Strategy selection
        self.strategy_weights = {
            RecommendationStrategy.PERSONALIZED: 0.6,
            RecommendationStrategy.POPULAR: 0.2,
            RecommendationStrategy.RANDOM: 0.1,
            RecommendationStrategy.HYBRID: 0.1
        }
        
        logger.info("âœ… Personalized Recommendation Engine initialized")
    
    async def generate_personalized_outfits(
        self,
        user_id: str,
        base_outfits: List[Dict[str, Any]],
        context: Dict[str, Any],
        max_outfits: int = 5
    ) -> RecommendationResult:
        """
        Generate personalized outfit recommendations
        
        Args:
            user_id: ID of the user
            base_outfits: Base outfits generated by the system
            context: Generation context (occasion, style, mood, etc.)
            max_outfits: Maximum number of outfits to return
        """
        try:
            logger.info(f"ðŸŽ¯ Generating personalized recommendations for user {user_id}")
            
            # Select recommendation strategy
            strategy = self._select_recommendation_strategy(user_id, context)
            
            # Generate recommendations based on strategy
            if strategy == RecommendationStrategy.PERSONALIZED:
                result = await self._generate_personalized_recommendations(
                    user_id, base_outfits, context, max_outfits
                )
            elif strategy == RecommendationStrategy.POPULAR:
                result = await self._generate_popular_recommendations(
                    user_id, base_outfits, context, max_outfits
                )
            elif strategy == RecommendationStrategy.RANDOM:
                result = await self._generate_random_recommendations(
                    user_id, base_outfits, context, max_outfits
                )
            else:  # HYBRID
                result = await self._generate_hybrid_recommendations(
                    user_id, base_outfits, context, max_outfits
                )
            
            # Add personalization metadata
            result.metadata.update({
                "user_id": user_id,
                "base_outfits_count": len(base_outfits),
                "recommended_count": len(result.outfits),
                "strategy_weights": self.strategy_weights,
                "personalization_weight": self.personalization_weight,
                "exploration_rate": self.exploration_rate
            })
            
            logger.info(f"âœ… Generated {len(result.outfits)} personalized recommendations using {strategy.value} strategy")
            return result
            
        except Exception as e:
            logger.error(f"âŒ Failed to generate personalized recommendations: {e}")
            # Fallback to base outfits
            return RecommendationResult(
                outfits=base_outfits[:max_outfits],
                strategy_used=RecommendationStrategy.RANDOM,
                personalization_score=0.0,
                confidence=0.5,
                metadata={"error": str(e)}
            )
    
    async def _generate_personalized_recommendations(
        self,
        user_id: str,
        base_outfits: List[Dict[str, Any]],
        context: Dict[str, Any],
        max_outfits: int
    ) -> RecommendationResult:
        """Generate recommendations using user embedding similarity"""
        
        # Get personalized recommendations from embedding service
        personalized_outfits = await self.embedding_service.get_personalized_recommendations(
            user_id, base_outfits, max_outfits
        )
        
        # Calculate personalization score
        personalization_score = self._calculate_personalization_score(
            user_id, personalized_outfits
        )
        
        # Calculate confidence based on user interaction history
        confidence = self._calculate_confidence(user_id, personalized_outfits)
        
        return RecommendationResult(
            outfits=personalized_outfits,
            strategy_used=RecommendationStrategy.PERSONALIZED,
            personalization_score=personalization_score,
            confidence=confidence,
            metadata={
                "personalization_method": "cosine_similarity",
                "user_embedding_available": user_id in self.embedding_service.user_embeddings
            }
        )
    
    async def _generate_popular_recommendations(
        self,
        user_id: str,
        base_outfits: List[Dict[str, Any]],
        context: Dict[str, Any],
        max_outfits: int
    ) -> RecommendationResult:
        """Generate recommendations based on popularity"""
        
        # Sort outfits by popularity metrics (wear count, rating, etc.)
        popular_outfits = sorted(
            base_outfits,
            key=lambda x: self._calculate_popularity_score(x),
            reverse=True
        )[:max_outfits]
        
        return RecommendationResult(
            outfits=popular_outfits,
            strategy_used=RecommendationStrategy.POPULAR,
            personalization_score=0.0,
            confidence=0.7,
            metadata={
                "popularity_method": "wear_count_and_rating",
                "outfits_scored": len(base_outfits)
            }
        )
    
    async def _generate_random_recommendations(
        self,
        user_id: str,
        base_outfits: List[Dict[str, Any]],
        context: Dict[str, Any],
        max_outfits: int
    ) -> RecommendationResult:
        """Generate random recommendations for exploration"""
        
        import random
        random_outfits = random.sample(
            base_outfits, 
            min(len(base_outfits), max_outfits)
        )
        
        return RecommendationResult(
            outfits=random_outfits,
            strategy_used=RecommendationStrategy.RANDOM,
            personalization_score=0.0,
            confidence=0.3,
            metadata={
                "randomization_method": "uniform_random",
                "exploration_purpose": True
            }
        )
    
    async def _generate_hybrid_recommendations(
        self,
        user_id: str,
        base_outfits: List[Dict[str, Any]],
        context: Dict[str, Any],
        max_outfits: int
    ) -> RecommendationResult:
        """Generate hybrid recommendations mixing personalized and popular"""
        
        # Get personalized recommendations
        personalized_result = await self._generate_personalized_recommendations(
            user_id, base_outfits, context, max_outfits // 2
        )
        
        # Get popular recommendations
        popular_result = await self._generate_popular_recommendations(
            user_id, base_outfits, context, max_outfits // 2
        )
        
        # Combine and re-rank
        combined_outfits = personalized_result.outfits + popular_result.outfits
        
        # Remove duplicates while preserving order
        seen_ids = set()
        unique_outfits = []
        for outfit in combined_outfits:
            outfit_id = outfit.get('id', '')
            if outfit_id not in seen_ids:
                unique_outfits.append(outfit)
                seen_ids.add(outfit_id)
        
        # Take top max_outfits
        final_outfits = unique_outfits[:max_outfits]
        
        # Calculate hybrid metrics
        personalization_score = (personalized_result.personalization_score + 0.0) / 2
        confidence = (personalized_result.confidence + popular_result.confidence) / 2
        
        return RecommendationResult(
            outfits=final_outfits,
            strategy_used=RecommendationStrategy.HYBRID,
            personalization_score=personalization_score,
            confidence=confidence,
            metadata={
                "personalized_count": len(personalized_result.outfits),
                "popular_count": len(popular_result.outfits),
                "combined_count": len(final_outfits)
            }
        )
    
    def _select_recommendation_strategy(
        self, 
        user_id: str, 
        context: Dict[str, Any]
    ) -> RecommendationStrategy:
        """Select the best recommendation strategy for the user and context"""
        
        # Check if user has sufficient interaction history
        user_stats = self.embedding_service.get_user_embedding_stats(user_id)
        has_sufficient_data = user_stats["total_interactions"] >= 5
        
        # Check if user has an embedding
        has_embedding = user_stats["has_embedding"]
        
        # Determine strategy based on user data and context
        if has_embedding and has_sufficient_data:
            # Use personalized strategy for users with data
            return RecommendationStrategy.PERSONALIZED
        elif has_embedding:
            # Use hybrid for users with embedding but limited data
            return RecommendationStrategy.HYBRID
        else:
            # Use popular for new users
            return RecommendationStrategy.POPULAR
    
    def _calculate_personalization_score(
        self, 
        user_id: str, 
        outfits: List[Dict[str, Any]]
    ) -> float:
        """Calculate how personalized the recommendations are"""
        
        if not outfits:
            return 0.0
        
        # Check if user has embedding
        user_embedding = self.embedding_service.user_embeddings.get(user_id)
        if user_embedding is None:
            return 0.0
        
        # Calculate average similarity (simplified)
        # In production, this would calculate actual similarities
        return 0.8  # Placeholder for demo
    
    def _calculate_confidence(
        self, 
        user_id: str, 
        outfits: List[Dict[str, Any]]
    ) -> float:
        """Calculate confidence in the recommendations"""
        
        user_stats = self.embedding_service.get_user_embedding_stats(user_id)
        
        # Base confidence
        confidence = 0.5
        
        # Increase confidence based on user interaction history
        if user_stats["total_interactions"] > 10:
            confidence += 0.2
        elif user_stats["total_interactions"] > 5:
            confidence += 0.1
        
        # Increase confidence if user has embedding
        if user_stats["has_embedding"]:
            confidence += 0.2
        
        # Increase confidence based on outfit quality
        if outfits:
            avg_confidence = np.mean([
                outfit.get('confidence', 0.5) for outfit in outfits
            ])
            confidence = (confidence + avg_confidence) / 2
        
        return min(confidence, 1.0)
    
    def _calculate_popularity_score(self, outfit: Dict[str, Any]) -> float:
        """Calculate popularity score for an outfit"""
        
        score = 0.0
        
        # Wear count
        wear_count = outfit.get('wearCount', 0)
        score += wear_count * 0.1
        
        # Rating
        rating = outfit.get('rating', 0)
        score += rating * 0.2
        
        # Favorite score
        favorite_score = outfit.get('favorite_score', 0)
        score += favorite_score * 0.3
        
        # Quality score
        quality_score = outfit.get('quality_score', 0.5)
        score += quality_score * 0.2
        
        # Recency bonus (if outfit was created recently)
        created_at = outfit.get('createdAt', 0)
        if created_at > 0:
            days_old = (time.time() - created_at / 1000) / (24 * 60 * 60)
            if days_old < 30:  # Recent outfits get bonus
                score += 0.1
        
        return score
    
    async def record_user_interaction(
        self,
        user_id: str,
        interaction: UserInteraction
    ) -> bool:
        """Record user interaction and update embeddings"""
        
        try:
            # Update user embedding based on interaction
            await self.embedding_service.update_user_embedding(user_id, interaction)
            
            logger.info(f"âœ… Recorded {interaction.interaction_type} interaction for user {user_id}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Failed to record interaction: {e}")
            return False
    
    def get_recommendation_analytics(self, user_id: str) -> Dict[str, Any]:
        """Get analytics about recommendations for a user"""
        
        user_stats = self.embedding_service.get_user_embedding_stats(user_id)
        
        return {
            "user_id": user_id,
            "total_interactions": user_stats["total_interactions"],
            "has_personalization": user_stats["has_embedding"],
            "recommended_strategy": self._select_recommendation_strategy(user_id, {}).value,
            "personalization_weight": self.personalization_weight,
            "exploration_rate": self.exploration_rate,
            "min_similarity_threshold": self.min_similarity_threshold
        }
    
    def update_recommendation_parameters(
        self,
        personalization_weight: Optional[float] = None,
        exploration_rate: Optional[float] = None,
        min_similarity_threshold: Optional[float] = None
    ):
        """Update recommendation parameters"""
        
        if personalization_weight is not None:
            self.personalization_weight = max(0.0, min(1.0, personalization_weight))
        
        if exploration_rate is not None:
            self.exploration_rate = max(0.0, min(1.0, exploration_rate))
        
        if min_similarity_threshold is not None:
            self.min_similarity_threshold = max(0.0, min(1.0, min_similarity_threshold))
        
        logger.info(f"âœ… Updated recommendation parameters: personalization_weight={self.personalization_weight}, exploration_rate={self.exploration_rate}")
